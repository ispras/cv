Инструментарий для ведения непрерывной верификации
--------------------------------------------------

1. Установка инструментария.

1.1. Установка дополнительных инструментов.

1.1.1. Проверить наличие требуемых зависимостей из инструкции docs/tools.txt (необходимо наличие прав администратора).
1.1.2. Скачать дополнительные инструменты (необходимо наличие доступа к репозиториям из инструкции docs/tools.txt):
make download -j8
1.1.3. Развернуть web-интерфейс для отображения результатов согласно инструкции docs/web_interface.txt.
1.1.4. (Опционально) Развернуть облако для параллельного решения задач на нескольких машинах согласно инструкции docs/verification_cloud.txt.

1.2. Установка плагинов.

Под плагином для инструментария понимается набор конфигурационных файлов, предназначенных для проверки некоторой системы.
Плагин для проверки системы с названием system_id необходимо поместить в директорию plugin/<system_id>.
Конфигурационные файлы плагина включают следующие директории:
- entrypoints (содержит описание генерируемых точек входа для верифицируемой системы) — добавляются файлы, описывающие множество точек входа и проверяемую подсистему (по шаблону);
- rules (содержит модели проверяемых правил корректности на языке C) – при проверке правила соответствующий ему C-файл будет добавлен в процесс сборки указанной подсистемы (в данном файле могут быть определены дополнительные проверки или переопределена семантика существующих функций);
- patches/sources (содержит патчи, которые необходимы для успешной сборки верифицируемой системы) – требуется добавить данные патчи при необходимости;
- patches/preparation (содержит конфигурацию для шага подготовки системы к верификации) – требуется добавить файл cong.json по шаблону;
- patches/tools/cpachecker (содержит специфические патчи для инструментов статической верификации) – требуется добавить данные патчи при необходимости;
- verifier_files/options (содержит конфигурацию для инструментов верификации) – при необходимости данные опции могут быть изменены;
- verifier_files/properties (содержит спецификации правил корректности) – для каждого правила корректности может быть добавлена его спецификация;
- configs (содержит предопределённые конфигурации для запуска инструментария) – данные конфигурации могут быть включать общие опции, необходимые для верификации данной системы;
- docs (содержит документацию) – при необходимости добавляется описание особенностей верификации данной подсистемы.
Таким образом, полностью сконфигурированный плагин для инструментария имеет следующий вид:
plugin/
-system_id/
--entrypoints/
---subsystem_1.json
...
---subsystem_k.json
--rules/
---common.h (при необходимости меняет шаблонный файл rules/common.h, который будет добавлен к каждому правилу)
---rule_1.c
...
---rule_n.c
--patches/
---sources/
----build.patch (применяется для успешной сборки системы)
----verification.patch (применяется для успешной верификации системы)
---preparation/
----conf.json
---tools/
----cpachecker/
-----trunk.patch (будет применён к ветке CPAchecker'а trunk)
--configs/
---config_1.json
---config_2.json
--docs/
---readme.txt
--verifier_files/
---properties/
----rule_1.spc
...
----rule_n.spc
---options
----memsafety.json (опции инструмента CPAchecker для проверки корректного использования памяти);
----races.json (опции инструмента CPAchecker для проверки отсутствия состояний гонки по данным);
----unreachability.json (опции инструмента CPAchecker для проверки заданных правил корректности rule_1, ..., rule_n).
В данном случае задачу верификации системы system_id можно декомпозировать на задачу верификации подсистем subsystem_1, ..., subsystem_k (в частности подсистема может совпадать со всей проверяемой системой), в каждой из которых задано некоторое множество точек входа.
При этом верификацию можно вести относительно либо 3-х встроенных правил корректности:
 - sync:races – правило для проверки отсутствия состояний гонки по данным;
 - sync:deadlocks – правило для проверки отсутствия ситуаций взаимных блокировок;
 - smg – правило для проверки корректного использования памяти;
либо относительно заданных правил корректности rule_1, ..., rule_n.

Если вся необходимая конфигурация плагина (на подобие указанного выше дерева директорий) для проверяемой системы помещена в отдельную директорию с абсолютным путём plugin_dir,
то ее можно установить, выполнив команду:
make install-plugin PLUGIN_DIR=<plugin_dir> PLUGIN_ID=<plugin_id>

Для удаления уже установленных плагинов необходимо выполнить команду:
make delete-plugins

1.3. Сборка инструментария.

Выполняется командой:
make build -j8
Команда может занять некоторое время (20-30 минут).
Примечание: если впоследствии будет установлен новый плагин, обновлен старый или обновлен один из патчей в корневой директории patches/tools/cpachecker,
то необходимо будет пересобрать инструменты статической верификации с учетом новых патчей командой:
make rebuild-cpa -j8

1.4. Развертка инструмента.

Развертка без облака:
make install -j8 DEPLOY_DIR=<рабочая директория>

Развертка с облаком:
make install-with-cloud -j8 DEPLOY_DIR=<рабочая директория> VCLOUD_DIR=<директория с развернутым облаком (п. 1.1.4)>

В дальнейшем все запуски необходимо производить из рабочей директории (установочные директории при необходимости могут быть удалены).

1.5. Настройка контрольных групп.
Для сиситем Ubuntu (12.04, 14.04, 16.04, 18.04) и Fedora 22 выполняется комендой:
./install_cgroups.sh
Данный шаг необходимо выполнять каждый раз после перезагрузки машины.

1.6 Настройка свопа.
При наличии установленных контрольных групп проверка наличия свопа выполняется командой:
if ls /sys/fs/cgroup/memory/memory.memsw.limit_in_bytes || ls /sys/fs/cgroup/memory.memsw.limit_in_bytes ; then
    echo "Swap is installed";
else
    echo "Swap is not installed";
fi
Если своп уже установлен, то данный шаг следует пропустить.
Базовый вариант.
1.6.1. Добавить "swapaccount=1" к значению переменной GRUB_CMDLINE_LINUX_DEFAULT в файле /etc/default/grub.
1.6.2. Выполнить sudo update-grub.
1.6.3. Перезагрузить машину.
1.6.4. Проверить наличие свопа в контрольных группах.
В директории контрольной группы подсистемы memory (по умолчанию /sys/fs/cgroup/memory/) должны присутствовать файлы вида memory.memsw.*. Если файлов нет, то потребуется альтернативный вариант настройки.
Альтернативный вариант: отключать своп командой
sudo swapoff -a
каждый раз после перезагрузки.

2. Запуск верификации.

2.1. Конфигурируемая проверка системы.
Цель - проверить заданную систему system_id, разбив ее на подсистемы subsystem_1, ..., subsystem_k, относительно правил корректности rule_1, ..., rule_n.

Предварительно необходимо создать конфигурацию по шаблону configs/example.json.
При задании конфигурации следует обратить внимание на следующие обязательные поля:
 - Preparator: extra options – дополнительные опции, которые будут использоваться при компиляции команд сборки;
 - Preparator: filter black list – шаблоны для исключения команд сборки;
 - Launcher: scheduler – планировщик (local – решение задания на локальной машине, cloud – решение задания в облаке (облако должно быть настроено – см. инструкцию docs/verification_cloud.txt));
 - Launcher: resource limits: CPU time – ограничение на процессорное время на один запуск верификатора в секундах;
 - Launcher: resource limits: memory size – ограничение на оперативную память на один запуск верификатора в GB;
 - Launcher: resource limits: number of cores – ограничение на число ядер процессора на один запуск верификатора;
 - Launcher: backup write – флаг, отвечающий за создание резервной копии для уже полученных результатов (по умолчанию выключен);
 - Launcher: backup read – флаг, отвечающий за чтение ранее полученных результатов из резервной копии (по умолчанию выключен);
 - cloud: master – адрес машины, на которой развёрнуто облако (требуется только при решении задач на облаке);
 - entrypoints desc – список файлов с описанием проверяемых точек входа (в примере subsystem_1, ..., subsystem_k);
 - rules – список проверяемых правил (в примере rule_1, ..., rule_n);
 - callers – список проверяемых точек входа (если данный параметр задан, то все остальные точки входа, описанные в entrypoints desc, будут проигнорированы);
 - commits – список проверяемых коммитов (если данный параметр задан, то будут проверены только обработчики, релевантные указанным коммитам, остальные будут проигнорированы); тег не совместим с тегом callers;
 - system – идентификатор системы (в примере system_id).
Для каждой директории с исходным кодом необходимо добавить в список Builder: sources элемент вида:
{
  "id": "произвольное название репозитория",
  "source dir": "абсолютный путь к директории",
  "branch": "ветка в репозитории системы",
  "build patch": "патч, который необходимо применить перед сборкой системы",
  "patches": ["список патчей, которые необходимо применить после сборки системы"],
  "build config": {
    "make command": "команда сборки системы (если директория требует сборки)"
  }
}

При проверке коммитов релевантность обработчика определяется следующим образом.
Для каждого коммита выявляется список функций, в которых выполнялись изменения, после чего находятся все обработчики, из которых данные функции могут вызываться.
Если полученный список функций пуст, то будут проверены все обработчики из подсистем, которые содержат измененные файлы.
Однако следует помнить, что не все зависимости могут быть отслежены таким образом, поэтому для более точной проверки можно либо непосредственно задать список обработчиков (тег callers), либо проверять все обработчики из затронутых коммитом подсистем.

Примечание: при задании ограничения на оперативную память (число ядер) следует учитывать, что оно должно быть меньше всей доступной оперативной памяти (числа ядер) на целевой машине. При этом параллельно будут запускаться N верификаторов, где
N = min(<доступная оперативная память>/<ограничение на оперативную память>, <доступное число ядер>/<ограничение на число ядер>) для сокращения астрономического времени верификации.

Если запуск подразумевает решение большого количества подзадач (их число отображается в логе «Launcher: INFO: Expected number of verifier launches is X», где X – число решаемых подзадач), исчисляемого сотнями, то запуск может занять довольно много времени и рекомендуется создавать резервную копию уже полученных результатов (посредством задания в конфигурации флага «Launcher: backup write»).
В данном случае если запуск верификации завершится некорректно, то информацию об уже завершенных запусках можно найти в файле backup_<название конфигурации>_<временная метка>.csv.
Для продолжения решения только оставшихся подзадач необходимо не удалять рабочую директорию («work_dir») и запустить ту же самую конфигурацию, установив флаг «Launcher: backup read» для считывания резервной копии.
При этом следует помнить, что при таком восстановлении части результата некоторые измерения ресурсов могут быть не точны (например, не удастся вычислить точное полное время работы скрипта).

Запуск производится посредством выполнения скрипта:
scripts/launcher.py --config <файлы с конфигурацией>
Если задано несколько конфигурационных файлов, то их верификация будет производиться последовательно.
Результатом запуска является архив с результатами results/results_<название конфигурации>_<временная метка>.zip.

2.2. Непрерывная проверка изменений в системе.
Цель – проверять каждый новый коммит в репозиторий системы по уже заданным конфигурациям.

Пусть имеется несколько конфигураций для инструментария config_1.json, ..., config_m.json, которые были получены на предыдущем шаге и проверены.

Для того, чтобы повторять их проверку на каждом новом коммите, необходимо задать общую конфигурацию по шаблону configs/auto.json, добавив туда данные по репозиторию, конфигурации config_1.json, ..., config_m.json и адреса электронной почты для рассылок уведомлений (необязательно).

Запуск автоматической проверки изменений осуществляется командой:
./scripts/auto_check.py -c <общая конфигурация>

3. Визуализация результата.

Предполагается, что web-интерфейс развернут (см. инструкцию docs/web_interface.txt) и известен хост <host> (по умолчанию 127.0.0.1) и порт <port>.

Для визуализации результатов необходимо выполнить следующие действия:
3.1. Получить номер отчета в web-интерфейсе. Номер задаётся в виде натурального числа. Если номер <id> уже имеется, то данный шаг можно пропустить и перейти на страницу отчета (<host>:<port>/jobs/<id>).
В противном случае потребуется открыть web-интерфейс (<host>:<port>), ввести имя пользователя и пароль, выбрать любой узел (нажать на ссылку) из появившегося дерева (столбец «Title»), выполнить действие «Make copy» - слева вверху, ввести название нового отчета (столбец «Title») и нажать «Save». После этого web-интерфейс перенаправит на страницу созданного отчета, его номер можно получить из адреса страницы (<host>:<port>/jobs/<id>).
3.2. Загрузить архив с результатами.
Архив, полученный на предыдущем этапе, необходимо загрузить на странице созданного отчета (<host>:<port>/jobs/<id>) web-интерфейса с помощью кнопки "Upload reports" - третья слева.
Для того чтобы автоматически загрузить архив во время верификации, необходимо:
 - создать отчет и получить его идентификатор (Identifier на странице отчета);
 - добавить в конфигурацию инструментария:
  "uploader": {
    "upload results": true,
    "identifier": "<идентификатор отчета>",
    "parent id": "true|false",
    "server": "<host>:<port>",
    "user": "<пользователь в web-интерфейсе, создавший отчет>",
    "password": "<пароль пользователя>"
  }
Если параметр «parent id» установлен в true, то для загрузки результатов будет создан новый отчет, который является потомком заданного (с помощью identifier). В противном случае результаты загружаются непосредственно в заданный отчет, при этом если с данным идентификатором ранее уже создавался отчет, то данная операция его сотрет.
После этого можно производить верификацию стандартным способом (см. пункт 2).

После загрузки на странице отчета появятся следующие секции:
 - «Unsafes» – ссылка на список найденных трасс ошибок;
 - «Safes» – ссылка на список доказательств корректности;
 - «Unknowns» – ссылка на список неуспешных завершений верификатора и других компонентов;
 - «Consumed resources» – таблица с затраченными ресурсами.

В каждом из списков для тройки <подсистема («Subsystem»), обработчик («Verification object»), правило корректности («Rule specification»)> представлена ссылка на более подробное описание (трасса ошибки / доказательство корректности / причина неуспешного завершения) и имеется некоторая дополнительная информация:
 - version – версия проверяемой системы;
 - Verifiers: CPU time | Wall time | RAM – ресурсы, потраченные верификатором на получение данного результата;
 - Traces – число найденных трасс ошибок с помощью инструмента (Initial) и число трасс после фильтрации (Filtered) – только для трасс ошибок;
 - Found all traces – показывает, были ли найдены все трассы ошибок для данной тройки, или нет – только для трасс ошибок;
 - Filtering time – процессорное время выполнения фильтрации в секундах – только для трасс ошибок;
 - Id – идентификатор трассы ошибки (для различия трасс, относящихся к одной тройке) – только для трасс ошибок;
 - Coverage – процент покрытия по строкам (Lines) и по функциям (Functions) в рамках данной тройки (то есть покрытие, которое данный обработчик обеспечивает в данной подсистеме) – только для доказательств корректности;
 - Relevancy – показывает, является ли проверяемое правило релевантным в рамках выбранного обработчика – только для доказательств корректности.

Для доказательств корректности на данный момент дополнительная информация не предоставляется.
Для каждого неуспешного завершения верификатора указывается соответствующая причина (например, «TIMEOUT» – исчерпание ограничения на процессорное время) и лог инструмента верификации.
Для каждой трассы ошибки предоставляется визуализация, которая предназначена для того, чтобы человеку было удобнее провести анализ и определить, соответствует ли она реальной ошибке в коде или является следствием ложного сообщения об ошибке. Для получения статистики по всему запуску рекомендуется создавать оценки (кнопка «Сreate lightweight mark»), которые будут автоматически применены при загрузке новых результатов (например, с более новой версией ядра), что может существенно упростить их анализ. Для этого необходимо указать вердикт («Bug» – истинная ошибка, «False positive» – ложное сообщение об ошибке, «Unknown» – неизвестно), статус исправления ошибки («Status») и причину ложного сообщения об ошибке («Tags»). Если в базе данных нет требуемой причины, то ее необходимо создать на странице Menu->Tags->Unsafe, далее либо «Create new root tag», либо «Create child».
После выполнения подобной разметки трасс ошибок на странице отчета в секции «Unsafes» появится статистика размеченных трасс.

Таблица с затраченными ресурсами содержит информацию по работе каждого компонента:
 - CPU time – процессорное время в секундах;
 - Memory – максимальный объем используемой компонентом оперативной памяти;
 - Wall time – астрономическое время работы компонента.
По умолчанию имеются следующие компоненты:
 - Core – суммарное количество затраченных ресурсов на весь процесс верификации;
 - Builder – отвечает за сборку исходного кода и извлечение команд сборки;
 - Qualifier – отвечает за выявление релевантных для указанных коммитов обработчиков (используется только если задан тег commits);
 - Preparator – отвечает за подготовку верификационных задач для каждой пары <подсистема, правило>;
 - CPAchecker – статический верификатор, который решает подготовленные задачи для каждой тройки <подсистема, правило, обработчик> (астрономическое время компонента не учитывает параллельные запуски);
 - MEA – отвечает за фильтрацию трасс ошибок;
 - Exporter – отвечает за подготовку финального отчета;
 - Launcher – отвечает за запуск всех остальных компонентов.

Если какой-либо из компонентов инструментария завершился с допустимыми проблемами (например, несколько команд сборки не было обработано), то в секции Unknowns будут присутствовать логи падений данных компонентов.

